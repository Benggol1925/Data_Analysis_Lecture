### day1 ###

#===========================================================
#  		                도움말 활용 (p.28~30)					
#===========================================================
help() #전체 Help 메뉴가 나타남
help(mean) #평균을 구하는 함수에 대한 Help
?mean
?“mean"
help("[[") #특수문자 등의 사용법에 대해서서도 help 기능을 이용할 수 있음
?"[["
       
help.search(“mean”) 
??mean
            
#패키지에 포함된 내용을 확인시 
help(package = “RODBC”)

#===========================================================
#  			               자료 출력 (p.38)					
#===========================================================
#print함수를 사용하여 출력 
print(summary(iris))

cat("Cat 함수 예쩨 : 1더기 5의 값은 ? ", 1+5, "\n")
cat("오늘의 날짜는 ? ", date(), "\n")

#===========================================================
#  			         변수 목록 보기	(p.39)				
#===========================================================
x <- 10
y <- 10
z <- c(1,2,3,4,5)

ls()

ls.str()

#===========================================================
#  			            변수 삭제	(p.40)				
#===========================================================
x <- 10
y <- 20
z <- 30
ls()  #생성된 변수 보기 
rm(x)  #x변수 삭제 
rm(list = ls()) #오브젝트 내의 모든 변수 삭제 

#===========================================================
#  			             벡터 생성 (p.41)					
#===========================================================
x <- 10
y <- c(1,2,3,4,5)
z <- c(x, y)
a <- c("one", "two", "three")
b <- c(TRUE, FALSE, TRUE)
c <- y - x
d <- c(y, a)

#===========================================================
#    	             데이터 import	(p.45)				
#===========================================================
#CSV 파일 가져오기 예시 1: read.csv()로 csv file import
system.time(DF1 <-read.csv("c:\\Rproject\\test.csv",stringsAsFactors=FALSE))

#CSV 파일 가져오기 예시 2 : read.table()로 csv file import
system.time(DF2 <- read.table("c:\\Rproject\\test.csv",header=TRUE,sep=",",quote="",
                              stringsAsFactors=FALSE,comment.char="",nrows=n,
                              colClasses=c("integer","integer","numeric",
                                           "character","numeric","integer")
                              
#CSV 파일 가져오기 예시 3 : fread()로 csv file import.
#이번에는 data.table package에서 제공하는 fread()함수를 사용하여 데이터를 호출해보자.
system.time(DT1 <- fread("c:\\Rproject\\test.csv"))
                              
#CSV 파일 가져오기 예시 4: read.csv.sql()로 csv file import
require(sqldf)
system.time(SQLDF <- read.csv.sql("c:\\Rproject\\test.csv",dbname=NULL))

#===========================================================
#    	                데이터 export (p.46)					
#===========================================================
#Sample Data 생성

n <- 1e6
DT <- data.frame( a=sample(1:1000,n,replace=TRUE),
                  b=sample(1:1000,n,replace=TRUE),
                  c=rnorm(n),
                  d=sample(c("foo","bar","baz","qux","quux"),n,replace=TRUE),
                  e=rnorm(n),
                  f=sample(1:1000,n,replace=TRUE) )

# CSV 파일로 저장하기 예시  1 
write.table(DT,"c:\\Rproject\\test.csv",sep=",",row.names=FALSE, quote=FALSE)

# CSV 파일로 저장하기 예시  2
write.csv(DT, “c:\\Rproject\\test.csv”,sep=“,”,row.names=FALSE, quote=FALSE)

#===========================================================
#    	                   벡터 (p.47)					
#===========================================================
seq(1, by=0.05, along=1:5)    #seq(시작값, by=증가분, 조건지정)
seq(1, 7, by=2)
seq(1, -1, by=-0.5)
seq(1,7,length=3)
rev(seq(1:5))   #rev : 자료의 순서를 역순으로 만드는 함수

rep(c(1,2,3),3)  #rep(a,b)는 a를 b만큼 반복
rep(1:3,3)      #a:b는 a부터 b까지의 수
rep(c(4,2), times=2)
rep(c(4,2), times=c(2,1))
rep(c(4,2), length=3)
paste("no", 1:5)     #반복되는 문자에 첨자를 붙여줌

#===========================================================
#                         벡터 (p.48)					
#===========================================================
v1 <- c(1,2,3)   #숫자형 벡터 생성
v2 <- c("a", "b", "c")   #문자형 벡터 생성
v3 <- c(T, F, T)
height <- c(160, 140, 155)     #height 벡터 생성
people <- c("Ned", "Jill", "Pat") 
names(height) <- people   #height 벡터의 원소에 이름을 할당
height["Ned"]
names(height) <- NULL      #height 벡터의 원소의 이름을 삭제

#===========================================================
#                         벡터 (p.49)					
#===========================================================
vec1 <- c(1,2,3,4,5)  #1~5까지 자료를 갖는 vec1 변수 생성
vec1[2]     #두 번째 자료
vec1[c(2,3,5)]    #vec1의 2, 3, 5의 값만 표현
vec1[c(-2,-3)]    #vec1의 2, 3번째 자료 값 삭제
vec1[vec1>2]    #vec1에서 2보다 큰 값만 표현
vec1[2] <- 6    #두 번째 위치의 2값이 6으로 대체됨
replace(vec1, 3, 2)   #vec1의 세 번째 자료를 2로 변경
append(vec1, 8, 5)    #vec1의 5번째 자료 다음에 8을 삽입
v1 <- 1:3
v2 <- 2:4
v1 * v2   #벡터의 각 원소간 곱셈

#===========================================================
#                         벡터 (p.50)					
#===========================================================
height <- 175   #height 스칼라 생성
heights <- c(160,140,155)   #heights 벡터 생성
heights[c(2,1,2)]    #heights의 2, 1, 2번째 원소 추출
heights <- append(heights, height)    #heights와 height를 결합
heights.1 <- append(heights,180,after=2)   #heights의 2번째 다음에 180 추가
heights <- replace(heights, 2,142)  #heights의 2번째 원소를 142로 변경
heights.2 <- replace(heights,c(2,4),c(140,142)) #2번째 140, 4번째 142로 변경
numbers <- 1:5  #1~5의 값을 갖는 벡터 생성
heights <- heights.2[2:4]  #heights.2에서 2~4번째 값까지만 생성
length(heights)    #벡터의 길이 지정

#===========================================================
#    	         				 행렬	(p.51)
#===========================================================
#행렬(matrix)은 여러 변수들이 이차원적으로 모여 있는 개체로, 
#행렬을 생성하기 위해서는 matrix() 함수를 사용
#matrix() 함수 이외에 cbind(), rbind(), dim() 등을 이용하여 행렬을 생성시킬 수 있음

matrix(1:9, nrow=3)                            #nrow  : 행의 개수 지정
matrix(c(1,4,7,2,5,8,3,6,9), byrow=T, ncol=3)  #ncol : 열의 개수 지정 byrow=T : 행 기준 행렬을 생성
r1 <- c(1,4,7)                                 #r1, r2, r3 행 벡터 생성
r2 <- c(2,5,8)
r3 <- c(3,6,9)
rbind(r1, r2, r3)                                #rbind : 행을 기준으로 결합
cbind(r1, r2, r3)                              #cbind : 열을 기준으로 결합

#===========================================================
#               				 행렬	(p.52)
#===========================================================
m1 <- 1:9
dim(m1) <- c(3,3)

#행렬과 관련된 여러 함수와 성분의 추출과 삭제 등에 관해 알아봄
mat <- matrix(c(1,2,3,4,5,6,7,8,9), ncol=3, byrow=T) #행 기준 3열의 행렬 생성
mat[1,]                                       #행렬 mat의 1행의 값
mat[,3]                                       #행렬 mat의 3열의 값
mat[mat[,3] > 4, 1]                           #3열에서 4보다 큰 행의 값 중 1열의 모든 값
mat[mat[,3] > 4, 2]                           #3열에서 4보다 큰 행의 값 중 2열의 모든 값
mat[2,, drop=F]                               #2행 값만을 추출
is.matrix(mat[2,,drop=F])                       #mat[2,,drop=F]가 행렬인지 확인

#===========================================================
#    	                  배열 (p.53)
#===========================================================
#배열의 속성 :  행렬의 속성과 같이 자료의 개수를 나타내는 length, 형태를 보여주는 mode, 
#각 차원의 벡터의 크기를 나타내는 dim 그리고 각 차원의 리스트 이름을 나타내는 dimnames로 구성

#배열의 생성
#배열을 생성하기 위한 함수로 array() 함수와 dim() 함수가 있음
array(1:6)                                      #1~6의 자료로 1차원 배열 생성
array(1:6, c(2,3))                              #1~6의 자료로 2차원 배열 생성
array(1:8, c(2,2,2))                             #1~8의 자료로 3차원 배열 생성
arr <- c(1:24)                                 #1~24의 자료 생성
dim(arr) <- c(3,4,2)                           #dim() 함수를 이용하여 3행 4열의 행렬 2개 생성

#===========================================================
#                        배열 (p.54)
#===========================================================
#배열의 연산
ary1 <- array(1:8, dim = c(2,2,2))  
ary2 <- array(8:1, dim = c(2,2,2))
ary1 + ary2                                    #자료의 덧셈
ary1 * ary2                                    #자료의 곱셈
ary1 %*% ary2                                #두 배열 원소들의 곱의 합
sum(ary1 * ary2)                             # ary1 %*% ary2 와 같은 결과를 냄

#배열원소의 추출 및 삭제
ary1[,,1]
ary1[1,1,]
ary1[1,,-2]

#===========================================================
#    	              데이터 프레임 (p.55)
#===========================================================
#data.frame() : 이미 생성되어 있는 벡터들을 결합하여 데이터 프레임을 생성
char1 <- rep(LETTERS[1:3],c(2,2,1))          #벡터 char1
num1 <- rep(1:3,c(2,2,1))                     #벡터 num1
test1 <- data.frame(char1, num1)              #test1 데이터 프레임 생성

#as.data.frame() :모든 다른 종류의 자료객체들을 데이터 프레임으로 변환
a1 <- c("a","b","c","d","e","f","g","h","i","j","k","l","m","n","o")
dim(a1) <- c(5,3)
test3 <- as.data.frame(a1)                     #a1을 데이터 프레임으로 변환

#===========================================================
#                    데이터 프레임 (p.56)
#===========================================================
df1 <- data.frame(Col1 = c("A","B","C"), Col2 = c(1,2,3), Col3 = c(3,2,1))
# df1[행, 열]
df1[ , "Col3"]  #결과 : 3, 2, 1 출력
df1[1, ]           #결과 : A  1  3 출력
df1[3, "Col1"]  #결과 : C 출력

#===========================================================
#    	                리스트 (p.57)					
#===========================================================
li <- list("top", c(2,4,6),c(T,F,T))              #list(문자, 숫자, 논리형 객체) 
li[[1]]                                        #[[1]]:첫 번째 성분

mat1 <- matrix(1:4, nrow=2)
list1 <- list("A", 1:8, mat1)
son <- list(son.name = c("Minsu", "Minchul"), son.cnt = 2, son.age = c(2.6))

#리스트 속성 : 벡터의 속성과 같이 자료의 개수, 형태, 구성요소의 이름 등을 보여주는 length, mode, names로 구성
length(son)                                   #son 리스트 자료의 개수
mode(son)                                    #son 리스트 자료의 형태
names(son)                                   #son 리스트 각 구성요소의 이름

#===========================================================
#                      리스트 (p.58)					
#===========================================================
#예제1(생성)
exm <- list(c("Abe", "Bob", "Carol", "Deb"),c("Weight","Waist")) #exm의 이름으로 list생성
exm[[2]]                                      #리스트의 2번째 성분
exm[[2]][2]                                  #2번째 성분 2번째 원소
names(exm) <- c("Rows","Columns")           #exm 리스트에 성분 이름 부여
exm$Rows                                    #exm의 Rows 성분만 표현
exm$Rows[2]                                 #Rows 성분 2번째 원소 표현
exm$Columns                                 #exm의 Columns 성분만 표현

#===========================================================
#                      리스트 (p.59)					
#===========================================================
#예제2(추가 및 삭제)
list1 <- list("A", 1:8)                         #list1 리스트 생성
list1[[3]] <- list(c(T, F))                      #세 번째 성분을 추가
list1[[2]][9] <- 9                             #두 번째 성분에 원소 추가
list1[3] <- NULL                             #세 번째 성분 삭제
list1[[2]] <- list1[[2]][-9]                   #두 번째 성분의 9번째 원소 삭제

#===========================================================
#                      리스트 (p.60)					
#===========================================================
#관련함수
#리스트는 성분에 리스트와 벡터 등을 사용할 수 있음
#예제1
a <- 1:10
b <- 11:15                                    #벡터 a, b 생성
klist <- list(vec1=a, vec2=b, descrip="example")
klist[[2]][5]                                  #두 번째 성분 vec2의 5번째 원소
klist$vec2[c(2,3)]                             #vec2의 2, 3번째 원소

#===========================================================
#    	                사칙연산 (p.62)					
#===========================================================
#산술연산자(사칙연산)
1+2 
x<-3
y<-2
x+y
x-y
x*y
x/y
a<-c(1,2)
b<-c(3,4)
a+b #벡터 변수의 덧셈
a-b #벡터 변수의 뺄셈
a*b #벡터 변수의 곱셈
a/b #벡터 변수의 나눗셈

A<-matrix(c(5,10,2,1), ncol=2)
B<-matrix(c(3,4,5,6), ncol=2)
A+B #행렬변수의 덧셈
A-B #행렬변수의 뺄셈
A*B #행렬변수의 곱셈
A/B #행렬변수의 나눗셈

#===========================================================
#                      사칙연산 (p.63)					
#===========================================================
2^2 #일반적인 숫자의 제곱(2의 2제곱)
x<-4
y<-3
x^y #값을 변수에 할당한 후에 제곱(4의 세제곱)
a<-c(4,5)
b<-c(2,3)
a^b #벡터변수의 제곱(구성 요소들간의 제곱, 4^2, 5^3)
A<-matrix(c(5,10,2,1), ncol=2)
B<-matrix(c(2,2,2,2), ncol=2)
A^B #행렬변수의 제곱(각 구성 요소들간의 제곱)

#%/% : 나눗셈에서 몫만 출력함
4%/%2 
x<-3
y<-2
x%/%y #실제 값이 1.5이지만 정수부분인 1만 출력

a<-c(7,2)
b<-c(3,4)
a%/%b #벡터 변수의 정수나눗셈

#===========================================================
#                      사칙연산 (p.64)					
#===========================================================
A<-matrix(c(5,10,2,1), ncol=2)
B<-matrix(c(3,4,5,6), ncol=2)
A%/%B #행렬변수의 정수나눗셈

#행렬의 곱
A<-matrix(c(5,10,2,1), ncol=2)
B<-matrix(c(3,4,5,6), ncol=2)
#(5*3) + (2*4) ; (5*5) + (2*6) ; (10*3) + (1*4) ; (10*5) + (1*6)
A%*%B

#===========================================================
#    	                비교연산 (p.65)
#===========================================================
# '==' 비교되는 두 항이 같은지를 비교함. 같을 경우 True, 다를 경우 False
1==2
x<-2
y<-3
x==y

# '!=' 비교되는 두 항이 다른지를 비교함. 같을 경우 False, 다를 경우 True
1!=2
x<-2
y<-3
x!=y

# '<=' 왼쪽 항이 오른쪽 항보다 작거나 같음을 비교함. 작거나 같으면 True, 크면 False
1<=2
x<-2
y<-2
x<=y

#===========================================================
#                      비교연산 (p.66)
#===========================================================
# '<' 왼쪽 항이 오른쪽 항보다 작음을 비교함. 작으면 True, 크면 False
1<2

# '>' 왼쪽 항이 오른쪽 항보다 큼을 비교함. 크면 True, 작으면 False
1>2

# '>=' 왼쪽 항이 오른쪽 항보다 크거나 같음을 비교함. 크거나 같으면 True, 작으면 False
1>=2

#===========================================================
#    	                 논리연산	(p.67)			
#===========================================================
# && : 일반적인 and 논리 연산자
2==2 && 3>4
# & : 벡터에서의 and 논리 연산자
2==2 && c(2==2, 3>4) #벡터에서 && 연산자를 사용해도 결과는 나오지만 틀린 결과가 출력된다.
2==2 & c(2==2, 3>4)
# || : 일반적인 or 논리 연산자
2==2 || 3>4
# | : 벡터에서의 or 논리 연산자
2!=2 || c(2==2, 3>4) #벡터에서 || 연산자를 사용해도 결과는 나오지만 틀린 결과가 출력된다.
2!=2 | c(2==2, 3>4)
# ! : not 연산자
!TRUE

#===========================================================
#    	            행/열 이름 알기	(p.68)				
#===========================================================
tmp_df <- data.frame(AA = c(1:5), BB = c("A","A","B","B","B"))

names(tmp_df) #열의 이름의 결과를 내보낸다.

colnames(tmp_df) #열의 이름의 결과를 내보낸다.

rownames(tmp_df) #행의 이름의 결과를 내보낸다.

dimnames(tmp_df) #열과 행의 이름의 결과를 내보낸다.

#===========================================================
#                행/열 이름 변경 (p.69)					
#===========================================================
names(tmp_df)[1] <- "AA_1" #첫번째 열의 이름을 변경한다.

names(tmp_df) <- c("AA_2", "BB_2") #첫번째 열과 두번째 열의 이름을 변경한다.

colnames(tmp_df)[1] <- "AA" #첫번째 열의 이름을 변경한다.

rownames(tmp_df)[1] <- "row1" #첫번째 행의 이름을 변경한다.

#===========================================================
#    	                 열 추가 (p.70)					
#===========================================================
tmp_df <- data.frame(AA = c(1:5), BB = c("A","A","B","B","B"))

#CC컬럼을 새로 생성하고 그 안에 값을 1로 채워 넣음 
tmp_df$CC <- 1

#컬럼 AA와 컬럼 CC의 값의 합한 값을 새로운 DD컬럼으로 생성
tmp_df$DD <- tmp_df$AA + tmp_df$CC

#===========================================================
#    	                 열 제거 (p.71)					
#===========================================================
tmp_df[, -1] #첫번째 위치의 컬럼 제거

tmp_df[, -"AA"]  #오류 발생함
#다음에 오류가 있습니다-"AA" : 단항연산자에 유효한 인자가 아닙니다

tmp_df[, c("BB","CC","DD")]

subset(tmp_df, select = -AA)

#===========================================================
#    	               데이터 추출 (p.72)					
#===========================================================
Sample.df <- data.frame(AA = rep(letters[1:5],10), BB = sample(60:70, 50, replace = T), stringsAsFactors = FALSE)

#AA컬럼의 값중에서 a인 값만 추출
#Type1
Sample.df[Sample.df$AA == "a",] 
#Type2
subset(Sample.df, AA == "a") 
#AA컬럼의 값중에서 a 와 b의 값만 추출
#Type1
Sample.df[Sample.df$AA %in% c("a","b"),]
#Type2
subset(Sample.df, AA %in% c("a","b"))

#===========================================================
#                     데이터 추출 (p.73)					
#===========================================================
# 필요한 컬럼 Select
Sample.df1 <- Sample.df
#Type1
Sample.df1[,c("AA","BB","CC")]
#Type2
Sample.df1[,c(1,2,3)]
#Type3
Sample.df1[,c(-4,-5)]
#Type4
subset(Sample.df1,select = c("AA","BB","CC"))
#Type5
subset(Sample.df1,select = c(AA, BB, CC))
#Type6
subset(Sample.df1,select = c(-CC1,-CC2))

#===========================================================
#    	                cbind (p.74)
#===========================================================
aa <- c(1:5)
bb <- c(5:1)
cbind(aa,bb)

tmp_df <- data.frame(AA = c(1:5), BB = letters[1:5])
cbind(tmp_df, aa)

#===========================================================
#    	             rbind (p.75)				
#===========================================================
rbind(aa, bb)

tmp_df1 <- data.frame(AA = c(1:2), BB = c("A","A"))
tmp_df2 <- data.frame(AA = c(3:4), BB = c("B","B"))
rbind(tmp_df1, tmp_df2)

#===========================================================
#    	                merge (p.76)
#===========================================================
tmp1 <- data.frame(AA = c("A","A","B"), BB = c(1,2,3))
tmp2 <- data.frame(AA = c("A","C"), CC = c("OLD", "NEW"))

#===========================================================
#                      merge (p.77)
#===========================================================
#전체 합치기 매칭이 안되는 값은 NA로 표시
merge(tmp1, tmp2, by = "AA", all = T)

#매칭이 되어지는 데이터만 합치기
merge(tmp1, tmp2, by = "AA", all = F)

#===========================================================
#                 데이터 분할하기 (p.78)
#===========================================================
split(tmp1, tmp1$AA)

#문장을 나눌 때는 strsplit 함수를 사용하면 된다
strsplit("A text I want to display with spaces", " ")

#===========================================================
#                 데이터 정렬하기 (p.79)
#===========================================================
a <- c(1,4,5,3,5,3,7) #벡터형태에서는 sort 함수를 사용하여 정렬
sort(a)

order(a) #값의 순위값을 나타낸다

sort(a, decreasing = T)

order(a, decreasing = T)

#===========================================================
#                 데이터 정렬하기 (p.80)
#===========================================================
tmp1 <- data.frame(AA = c("A","A","B","C","D"), BB = c(5,3,6,1,2))
tmp1[order(tmp1$BB),] #오름차순 정렬

tmp1[order(tmp1$BB, decreasing = T), ] #내림차순 정렬

#===========================================================
#                   조건문 (p.81)
#===========================================================
#특정한 조건을 만족했을 경우에만 프로그램 코드를 수행하는 제어 구문. 항상 논리 연산이 수반 된다
#if(조건) 실행문
x <- c(1,2,3,4); y <- c(2,1,4,5)
if(sum(x) < sum(y)) print(x) #x의 합이 y의 합보다 작을 경우 실행

#if(조건) 조건이 참일 때 실행문 else 조건이 참이 아닐 때 실행문
#괄호안의 조건이 참이면 참일때의 실행문을 수행하고 거짓일 때는 참이 아닐때의 실행문을 수행하는 표현식
x <- c(1,2,3,4)
y <- c(2,1,4,5)
if(mean(x)>mean(y)) print("Mean(x)>Mean(y)") else print("Mean(x)<Mean(y)")


#===========================================================
#                  조건문 (p.82)
#===========================================================
#중첩 조건문 : 조건문 안에 조건문이 있는 표현식
if(length(x)==5) {
  if(sum(x) == 10) print("length=5, sum=10")
} else {
  print("length=4, sum=10")
}

#ifelse(조건, 조건이 참일때의 실행문, 조건이 참이 아닐때의 실행문)
ifelse(x<y, x, y)
ifelse(sum(x-y) > 0, "positive", ifelse(sum(x-y) < 0 , "negative", "zero"))

#===========================================================
#                  반복문 (p.83)
#===========================================================
# for(변수 in 반복횟수) 실행문 : 실행문을 반복횟수만큼 실행

#예제1
#변수 i가 1에서 5까지의 값을 갖을 때까지 print(rep(i,i))라는 실행문을 실행한다. 
#i=1이면 print(rep(1,1))을 실행하고 i=2이면 print(rep(2,2))을 실행한다. 이렇게 i=5일때까지 실행을 하게된다.
for(i in 1:5) print(rep(i,i))

#예제2 : 1부터 10까지 합 구하기
sum.x<-0
for(i in 1:10)
  sum.x<-sum.x + i
sum.x

#===========================================================
#  		      위치 측도와 산포 측도	(p.90)				
#===========================================================
#데이터는 어떤 과목의 시험성적을 나타낸다.

#plot
plot(exam)

#기본 정보
summary(exam)

### 위치 측도 ###
#표본평균
mean(exam)

#중앙값
median(exam)

#p% 분위수 
p <- 0.2
quantile(exam,0.2)

### 산포 측도 ###
#표본분산
var(exam)

#표본표준편차
sd(exam)

#평균 절대 편차
mad(exam)

#사분위수 범위
IQR(exam) 

#===========================================================
#  		             상관 계수와 공분산	(p.94)				
#===========================================================
#데이터 :보스톤시의 공원에서 10일동안 공원에서 해당 일에 근무중인 방범대원의 수 (x)와 보고된 좀도둑의 건수(y) 

#데이터
x <- c(10,15,16,1,4,6,18,12,14,7)
y <- c(5,2,1,9,7,8,1,5,3,6)

#산점도 
plot(x,y)

#표본상관계수
cor(x,y)

#표본공분산 
cov(x,y)
cor(x,y)*sd(x)*sd(y)

#===========================================================
#  		                  왜도와 첨도 (p.96)					
#===========================================================
#데이터 : 미국의 옐로스톤 국립공원 (Yellowstone National Park)에 있는 올드페이스풀간헐천(Old Faithful Geyser)에서 측정한 분출 시간(분) 

#히스토그램
hist(erup)

#왜도
skewness(erup)

#첨도
kurtosis(erup) 

#===========================================================
#  		           도수분포표와 줄기-잎 그림 (p.98)					
#===========================================================
#데이터 : 위치측도, 산포측도의 실습에서 사용했던 시험성적 데이터

#도수분포표
#50부터 100까지 계급의 수는 5개로
frequency.table <- cut(exam,br=seq(50,100,5))
table(frequency.table)

#줄기 잎 그림
stem(exam) 

#===========================================================
#  		                 히스토그램 (p.100)					
#===========================================================
#데이터 : 올드페이스풀간헐천 자료
#ggplot의 함수 사용 

#빈도 히스토그램
ggplot(faithful, aes(x=eruptions)) 
 geom_histogram(binwidth=.5, 
                 colour="black", fill="white")

#확률 분포 히스토그램 
ggplot(faithful, aes(x=eruptions)) 
 geom_histogram(aes(y=..density..), 
                 binwidth=.5, colour="black", fill="white") 
 geom_density()

#===========================================================
#  		                  상자그림 (p.102)					
#===========================================================
#데이터 : 올드페이스풀간헐천 자료
#ggplot의 함수 사용 

#상자그림
ggplot(faithful, aes(x=1, y=eruptions)) 
 geom_boxplot()

#상자그림에서 나타내는 것
summary(faithful$eruptions)

#그룹 별로 상자 그림 나타내기
#데이터는 표준정규분포에서 생성 
ggplot(dat, aes(x=Cond, y=Value, fill=Cond)) 
 geom_boxplot() 

#그룹 별로 상자 그림 나타내기
#데이터는 표준정규분포에서 생성

ggplot(dat, aes(x=Cond, y=Value, fill=Cond)) 
     + geom_boxplot()
